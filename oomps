#!/usr/bin/env python3

# Copyright (c) 2020 James Boyden <jboy@jboy.me>. All rights reserved.
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

"""Like `ps` or `top`, but for per-process memory usage & Linux OOM Score."""

import os
import re
import shutil

# https://github.com/pallets/click
# https://pypi.org/project/click/
# https://palletsprojects.com/p/click/
# https://click.palletsprojects.com/en/7.x/
import click
from psquery import api as psquery_api


def _get_default_fields():
    """Return the default fields as a list of strings."""
    _default_fields = "user pid ppid start dtime vszh adj ooms cmds"
    return _default_fields.split()


def _help_list_fields(ctx, param, value):
    """List all fields and exit.

    The beautiful-looking parameters to this function are how Click does
    "help" options that exit.
    """
    # This beautiful boilerplate is how Click does "help" options that exit.
    if not value or ctx.resilient_parsing:
        return

    (headers, all_fields) = psquery_api.list_all_fields(return_headers=True, descr=True)
    default_fields = set(_get_default_fields())

    click.echo("Fields that may be queried: (default fields marked by '*')")
    # TODO: Format this using the proper Click `HelpFormatter`.
    click.echo("    %-7s %-3s %s" % headers)
    for f in all_fields:
        (name, key, descr) = f
        is_default_field = (name in default_fields)
        # TODO: Format this using the proper Click `HelpFormatter`.
        click.echo("  %s %-7s %-3s %s" % ('*' if is_default_field else ' ', name, key, descr))

    ctx.exit()


def _help_list_fields_md(ctx, param, value):
    """List all fields (in a Markdown-format table) and exit.

    The beautiful-looking parameters to this function are how Click does
    "help" options that exit.
    """
    # This beautiful boilerplate is how Click does "help" options that exit.
    if not value or ctx.resilient_parsing:
        return

    (headers, all_fields) = psquery_api.list_all_fields(return_headers=True, descr=True)
    default_fields = set(_get_default_fields())

    click.echo("| %s | Is Default | %s | %s |" % headers)
    click.echo("| -- | ---------- | -- | -- |")
    for f in all_fields:
        (name, key, descr) = f
        is_default_field = (name in default_fields)
        # TODO: Format this using the proper Click `HelpFormatter`.
        click.echo("| `%s` | %s | `%s` | %s |" % (name, 'Y' if is_default_field else ' ', key, descr))

    ctx.exit()


@click.command()
@click.option('-a', '--all-procs', is_flag=True,
        help="Select: all processes that have a TTY.")

@click.option('-A', '--really-all-procs', is_flag=True,
        help="Select: ALL processes, even without a TTY.")

@click.option('-o', '--sort-by-oom', 'sort_by_field_options', multiple=True, flag_value="ooms",
        help="Sort:   by (ascending) OOM Score.")

@click.option('-O', '--rev-sort-by-oom', 'sort_by_field_options', multiple=True, flag_value="-ooms",
        help="Sort:   by descending OOM Score.")

@click.option('-r', '--sort-by-rsz', 'sort_by_field_options', multiple=True, flag_value="rszk",
        help="Sort:   by (ascending) resident set size.")

@click.option('-R', '--rev-sort-by-rsz', 'sort_by_field_options', multiple=True, flag_value="-rszk",
        help="Sort:   by descending resident set size.")

@click.option('-s', '--sort-by-start', 'sort_by_field_options', multiple=True, flag_value="starts",
        help="Sort:   by (ascending) start time.")

@click.option('-S', '--rev-sort-by-start', 'sort_by_field_options', multiple=True, flag_value="-starts",
        help="Sort:   by descending start time.")

@click.option('-v', '--sort-by-vsz', 'sort_by_field_options', multiple=True, flag_value="vszk",
        help="Sort:   by (ascending) virtual memory size.")

@click.option('-V', '--rev-sort-by-vsz', 'sort_by_field_options', multiple=True, flag_value="-vszk",
        help="Sort:   by descending virtual memory size.")

@click.option('--help-list-fields', is_flag=True, is_eager=True, expose_value=False,
        callback=_help_list_fields,
        help="List all fields and exit.")

@click.option('--help-list-fields-md', is_flag=True, is_eager=True, expose_value=False,
        callback=_help_list_fields_md,
        help="List all fields (in Markdown format) and exit.")

@click.argument('args', nargs=-1)
def oomps(
        all_procs,
        really_all_procs,
        sort_by_field_options,
        args):
    """Like `ps` or `top`, but for per-process memory usage & Linux OOM Score.

    \b
    This command runs in 3 stages:
     1. Select (processes) by specified criteria (default: caller's UID).
     2. Sort (processes) by specified field criteria (default: PID).
     3. Print (process field values) to stdout, in column-based format.

    There may be any number of [ARGS], in any order.  [ARGS] are used for
    selecting processes and specifying which fields (process attributes)
    should be included in the print to stdout.

    \b
    [ARGS] for selecting processes may be any of:
      ~                 Select processes owned by the caller's UID.

    \b
      +                 Select processes owned by the caller's UID.
      +<uid>            Select processes owned by integer UID <uid>.

    \b
      %                 Select all processes that have a TTY.
      %<exestart>       Select processes that have a TTY, that also have
                            executable name starting with `<exestart>`.

    \b
      %%                Select ALL processes, even without a TTY.
      %%<exestart>      Select processes, even without a TTY, that have
                            executable name starting with `<exestart>`.

    \b
      <pid>             Select process with integer PID `<pid>`.
      <pid>,<pid>       Select processes with PIDs in comma-separated list.

    A process is selected if ANY of the selection criteria match.
    (So the selection criteria "OR" together.)

    If no [ARGS] are specified for process selection, the selection criteria
    default to `~` (select processes owned by the caller's UID).  This is
    similar to how the `ps` command behaves without command-line arguments.

    When an argument accepts a comma-separated list, the list may instead
    be whitespace-separated if the caller prefers (but a single list may NOT
    contain both commas and whitespace).

    \b
    [ARGS] for specifying which fields should be shown may be any of:
      .<field>              Show <field> first in columns.
      .<new>/<old>          Replace <old> field with <new> in-place.
      ./<field>             Remove <field> field from columns.
      ..<field1>,<field2>   Show <field1>,<field2> list first in columns.

    \b
      ==<field1>,<field2>   Specify exactly which fields should be shown
                                (completely overriding the default).

    To see which fields may be shown, use option `--help-list-fields`.
    A field may be specified by its field name or its 1-character field key.
    """
    (fields_to_show, selection_criteria) = \
            _parse_args(all_procs, really_all_procs, args)

    # Parse the sorting options.
    sort_by_fields = []
    # If none of the `sort_by_field_options` flags are specified, the default
    # of `sort_by_field_options` will be `None`, not an empty collection.
    # You can't iterate over `None`!
    if sort_by_field_options:
        for flag_value in sort_by_field_options:
            if flag_value.startswith('-'):
                # It's a reverse sort, eg "-vszk".
                sort_by_fields.append(psquery_api.SortByField(flag_value[1:], reverse=True))
            else:
                sort_by_fields.append(psquery_api.SortByField(flag_value))
    # The first sort field should be the highest priority; the second should
    # be the second-highest priority; etc.  So we'll maintain this ordering,
    # but put them all into a tuple.
    sort_by_fields = tuple(sort_by_fields)

    # Long lines will be automatically truncated if this script's output is
    # connected to a terminal.  Otherwise, if this script's output is connected
    # to a pipeline (such as `less` or even just `cat`), long lines will NOT be
    # truncated.
    #
    # Helpful Tip: If you're using `less`, use `less -S` to truncate long lines
    # of output at the terminal width (rather than the default of wrapping).
    terminal_width = _get_terminal_width()

    # Observe:  We pass an *ordered* collection (a tuple) `fields_to_show`
    # into function `psquery_api.query_fields`.  This ensures that we receive
    # a `QueriedProcess` named-tuple result that has fields in an order that's
    # predictable & useful to us.
    (queried_procs, field_types, memory_info, overcommit_settings) = \
            psquery_api.query_fields(fields_to_show,
                    selection_criteria=selection_criteria,
                    sort_by_fields=sort_by_fields,
                    return_field_types=True, return_header_info=True)

    click.echo(_format_memory_info(memory_info))
    click.echo(_format_overcommit_settings(overcommit_settings))

    #field_formats = [("{:%s}" % ft.rec_max_len) for ft in field_types]
    # Make use of the tuple-nature of namedtuple `QueriedProcess`:
    # Use old-style `("%s %s %s" % tup)` string-formatting.
    field_formats = [
            ("%%%s%ds" % ("-" if ft.alignment == 'L' else "", ft.rec_max_len))
            for ft in field_types]
    # But don't pad the last field with trailing whitespace.
    # That is, if the last field is left-aligned, don't pad it.
    if field_types[-1].alignment == 'L':
        # The last field *is* left-aligned, so it *has* been padded
        # with trailing whitespace.  Change the last format string
        # so the last field will *not* be padded.
        field_formats[-1] = "%-s"
    proc_format = " ".join(field_formats)
    click.echo((proc_format % tuple(fields_to_show)).upper()[:terminal_width])
    for qp in queried_procs:
        # Make use of the tuple-nature of namedtuple `QueriedProcess`.
        # Use old-style `("%s %s %s" % tup)` string-formatting.
        click.echo((proc_format % qp)[:terminal_width])


class ParsedFieldsToShow(object):
    def __init__(self, all_fields_defined, default_fields):
        # A look-up table of field name -> field key.
        self._all_fields_by_name = dict(all_fields_defined)
        # A look-up table of field key -> field name.
        self._all_fields_by_key = dict(
                (key, name)
                for name, key in all_fields_defined
                if key)

        self._main_fields_to_show = list(default_fields)
        self._first_fields_to_show = []


    def _get_field_name(self, field):
        if field in self._all_fields_by_name:
            # Is it a field name?  Otherwise, fall-back to checking field key.
            return field
        else:
            # Is it a field key?  Raise `KeyError` if key not found.
            return self._all_fields_by_key[field]


    def deliver(self):
        if len(self._first_fields_to_show) > 0:
            return tuple(self._first_fields_to_show) + tuple(self._main_fields_to_show)
        else:
            return tuple(self._main_fields_to_show)


    def override_fields(self, fields):
        if not fields:
            # We will not override the fields to show with NO fields.
            raise ValueError("missing field names or field keys")

        if isinstance(fields, str):
            # We assume `fields` is a single string of multiple
            # single-character field keys.
            # Expand them to the field names that we will store.
            # Raise `KeyError` if key not found.
            all_fields_by_key = self._all_fields_by_key
            fields = [all_fields_by_key[c] for c in fields]
        else:
            # We assume `fields` is a sequence of field name strings.
            # Let's verify their validity.
            all_fields_by_name = self._all_fields_by_name
            for f in fields:
                all_fields_by_name[f]

        self._main_fields_to_show = list(fields)
        self._first_fields_to_show.clear()


    def remove_field(self, old_field):
        # Complain about empty strings specially.
        # Of course, this situation would be handled (raising a `KeyError`)
        # by the check in `self._get_field_name`, because the empty string
        # will not be a valid field name or field key.
        #
        # But the error messages for these terse command-line options can be
        # a little cryptic.  So let's report an error as clearly as possible.
        if not old_field:
            raise ValueError("missing field name or field key")

        # This will also verify that `old_field` is a valid field name or key.
        field_name = self._get_field_name(old_field)
        field_in_main = (field_name in self._main_fields_to_show)
        field_in_first = (field_name in self._first_fields_to_show)

        if not (field_in_main or field_in_first):
            # This field is already NOT specified to be shown.
            raise ValueError("field is already NOT shown, so cannot be removed: %r" %
                    old_field)

        # Otherwise, this field *is* specified to be shown, so let's remove it.
        if field_in_main:
            self._main_fields_to_show.remove(field_name)
        if field_in_first:
            self._first_fields_to_show.remove(field_name)


    def replace_field_in_place(self, old_field, new_field):
        # Complain about empty strings specially.
        # Of course, this situation would be handled (raising a `KeyError`)
        # by the check in `self._get_field_name`, because the empty string
        # will not be a valid field name or field key.
        #
        # But the error messages for these terse command-line options can be
        # a little cryptic.  So let's report an error as clearly as possible.
        if not old_field or not new_field:
            raise ValueError("missing field name or field key")

        # This will also verify that `old_field` is a valid field name or key.
        old_field_name = self._get_field_name(old_field)
        old_field_in_main = (old_field_name in self._main_fields_to_show)
        old_field_in_first = (old_field_name in self._first_fields_to_show)

        # This will also verify that `new_field` is a valid field name or key.
        new_field_name = self._get_field_name(new_field)
        new_field_in_main = (new_field_name in self._main_fields_to_show)
        new_field_in_first = (new_field_name in self._first_fields_to_show)

        if not (old_field_in_main or old_field_in_first):
            # This field is already NOT specified to be shown.
            raise ValueError("field is already NOT shown, so cannot be removed: %r" %
                    old_field)

        if (new_field_in_main or new_field_in_first):
            # This field is already specified to be shown.
            raise ValueError("field is already shown, so cannot be inserted as replacement: %r" %
                    new_field)

        # Otherwise, the old field *is* specified to be shown,
        # so let's replace it by the new field in-place.
        if old_field_in_main:
            idx = self._main_fields_to_show.index(old_field_name)
            self._main_fields_to_show[idx] = new_field_name
        if old_field_in_first:
            idx = self._first_fields_to_show.index(old_field_name)
            self._first_fields_to_show[idx] = new_field_name


    def show_field_first(self, new_field):
        # Complain about empty strings specially.
        # Of course, this situation would be handled (raising a `KeyError`)
        # by the check in `self._get_field_name`, because the empty string
        # will not be a valid field name or field key.
        #
        # But the error messages for these terse command-line options can be
        # a little cryptic.  So let's report an error as clearly as possible.
        if not new_field:
            raise ValueError("missing field name or field key")

        # This will also verify that `new_field` is a valid field name or key.
        field_name = self._get_field_name(new_field)
        field_in_main = (field_name in self._main_fields_to_show)
        field_in_first = (field_name in self._first_fields_to_show)

        # It's not an error if this field is already specified to be shown;
        # just move it to the end of the "first fields" list.
        if field_in_main:
            self._main_fields_to_show.remove(field_name)
        if field_in_first:
            self._first_fields_to_show.remove(field_name)

        self._first_fields_to_show.append(field_name)


    def show_fields_first(self, new_fields):
        # Even though inserting zero number of fields as the first fields
        # is not really a problem (since it's technically a no-op), it's
        # still invalid syntax.
        if not new_fields:
            # We will not override the fields to show with NO fields.
            raise ValueError("missing field names or field keys")

        if isinstance(new_fields, str):
            # We assume `new_fields` is a single string of multiple
            # single-character field keys.
            for c in new_fields:
                self.show_field_first(c)
        else:
            # We assume `new_fields` is a sequence of field name strings.
            for f in new_fields:
                self.show_field_first(f)


class ParsedSelectionCriteria(object):
    def __init__(self, default=None):
        self.selection_criteria = set()
        self.really_all_procs = False
        self._default = default

    def deliver(self):
        """Deliver a possibly-empty tuple of parsed selection criteria."""
        if self.really_all_procs:
            # Select ALL processes, even processes NOT associated with a TTY.
            # After this option or arg, all other args are redundant.
            return ()
        elif len(self.selection_criteria) > 0:
            # Convert the `set` to a `tuple` for consistency with the other two
            # return values.
            return tuple(self.selection_criteria)
        else:
            return (self._default,)


def _parse_args(all_procs, really_all_procs, args):
    """Parse the non-option command-line args, and the few "widening" options.

    These parsed args will yield:
     - which fields to show
     - the initial process selection criteria (before any filtering options)
    """
    all_fields_defined = psquery_api.list_all_fields()
    default_fields = list(_get_default_fields())
    parsed_fields_to_show = ParsedFieldsToShow(all_fields_defined, default_fields)

    # The (real) UID of the user who called this function ("the caller").
    this_process_ruid = os.getuid()
    # The home directory of the user who called this function.
    this_process_home = os.path.expanduser("~")
    # If no selection criteria are specified, default to matching processes
    # that have (real) UID matching the caller.
    default_uid_criterion = psquery_api.ProcessUidEquals(this_process_ruid)
    parsed_selection_criteria = ParsedSelectionCriteria(default_uid_criterion)

    if really_all_procs:  # option "-A"
        # Select ALL processes, even processes NOT associated with a TTY.
        # After this option or arg, all other args are redundant.
        parsed_selection_criteria.really_all_procs = True
    elif all_procs:  # option "-a"
        parsed_selection_criteria.selection_criteria.add(psquery_api.ProcessHasTty())

    # Note:  Bash shell will expand/replace a command-line argument tilde (`~`)
    # with the caller's home-directory, in-place (ie, replace the `~` argument
    # so that we never see a `~` string).
    #
    #   Input:    Bash & Python `os.path.expanduser()`:
    #   ~         /home/jboy
    #   ~tom      /home/tom
    #   ~,        ~,
    #   ~,tom     ~,tom
    #   ~,~tom    ~,~tom
    #   ~tom,     ~tom,
    #
    # Further, when the caller specifies `~` or `~username` as a command-line
    # argument, we might instead receive an argument that starts with a slash
    # (`/`).  So we also can't use `/` as the start of some other command.
    #
    # Here are some other special characters in Shell that we can't use at all
    # (unless surrounded by quotes, sometimes only single quotes):
    #  - `#` (comment until end-of-line)
    #  - `;` (statement separator)
    #  - `!` (invert the exit status of a command; also, history substitution)
    #  - `$` (shell variable)
    #  - `&` (run job in background)
    #  - `|` (pipe)
    #  - `>` and `<` (redirection to/from files)
    #  - `?` and `*` (shell filename wildcards)
    # From https://tldp.org/LDP/abs/html/special-chars.html
    #
    # We also can't use `:` as a stand-alone (it's a shell built-in command,
    # synonymous with `true`).
    #
    # That leaves:
    #  - `,`
    #  - `.`
    #  - `=`
    #  - `+`
    #  - `^`
    #  - `@`
    #  - `%`
    #
    # So, we'll use the following syntax:
    #  - `~user`: match processes owned by user named `user`
    #  - `~+123`: match processes owned by user with UID 123
    #  - `~~user`: match processes owned by effective user named `user`
    #  - `~~+123`: match processes owned by effective user with UID 123
    #  - `123`: match process with PID 123
    #  - `^123`: match process with Parent PID 123 (inspired by Git syntax)
    #  - `%comm`: match all TTY processes whose exe name starts with `comm`
    #     (Note that executable names might start with integer digits.)
    #  - `%%comm`: match ALL processes whose exe name starts with `comm`
    #  - `.field`: prepend new field to list of fields to show
    #  - `.newfield/oldfield`: replace `oldfield` with `newfield` in-place
    #  - `./oldfield`: remove `oldfield`
    #  - `..field,field`: prepend multiple fields to list of fields to show
    #  - `==field1,field2`: override the whole list of fields
    #
    # Note #2:  We will allow per-argument lists to be separated by EITHER
    # one comma OR one-or-more spaces, but not both (for our own sanity);
    # or else it's too much of a chore to detect that ", ," or ",  ," (etc)
    # is invalid.
    for arg_num, arg in enumerate(args, start=1):
        # Ensure that no argument list contains both commas AND spaces.
        contains_commas = ',' in arg
        contains_spaces = re.search("\\s", arg)
        if contains_commas and contains_spaces:
            raise click.BadParameter(
                    "list contains both commas AND spaces: %r" % arg,
                    param_hint=("arg %d" % arg_num))
        # Ensure that no argument contains multiple adjacent commas (ie, `,,`).
        # This is just a good old-fashioned syntax error, but we handle it here
        # so we only need to check and handle it once.
        if ',,' in arg:
            raise click.BadParameter(
                    "list contains adjacent commas with no value between: %r" % arg,
                    param_hint=("arg %d" % arg_num))

        if arg.startswith("%"):
            _parse_arg_start_percent(arg_num, arg, parsed_selection_criteria)
        elif arg.startswith("+"):
            _parse_arg_start_plus(arg_num, arg, parsed_selection_criteria, default_uid_criterion)
        elif arg == "~" or arg == this_process_home:
            # Match the caller's UID.
            parsed_selection_criteria.selection_criteria.add(default_criterion)
        elif arg.startswith("."):
            _parse_arg_start_dot(arg_num, arg, parsed_fields_to_show,
                    contains_commas, contains_spaces)
        elif arg.startswith("="):
            _parse_arg_start_equals(arg_num, arg, parsed_fields_to_show,
                    contains_commas, contains_spaces)
        else:
            # The only type of argument that doesn't begin with a single
            # well-defined character or multi-character sequence, is the only
            # type of argument that we haven't yet checked:  Try to parse &
            # match an integer Process ID (or match a comma/space-separated
            # sequence of integers, to match several Process IDs).
            #
            # If this doesn't match, then the argument is invalid.
            _try_parse_pid_list(arg_num, arg, parsed_selection_criteria,
                    contains_commas, contains_spaces)

    return (parsed_fields_to_show.deliver(), parsed_selection_criteria.deliver())


def _parse_arg_start_dot(arg_num, arg, parsed_fields_to_show,
        contains_commas, contains_spaces):
    """Parse a command-line arg that starts with 1 or more dot (`.`) characters.

    Args that start with 1 or more dot characters, all relate to specifying
    fields that should be added or removed from the list of fields to show.
    """
    if arg.startswith(".."):
        # The argument after `..` should be multiple fields, whether a list of
        # multiple comma/space-separated field names, or multiple field keys in
        # a single string.
        fields = arg[2:]
        if contains_commas or contains_spaces:
            # There are commas or spaces => Assume it's a list of field names.
            # Replace commas with spaces, so we only need to do one split.
            # Note that `.split()` also strips any leading & trailing whitespace.
            fields = (fields.replace(",", " ") if contains_commas else fields).split()
        try:
            parsed_fields_to_show.show_fields_first(fields)
        except KeyError as e:
            raise click.BadParameter(
                    "no such field name or field key %s: %r" % (str(e), arg),
                    param_hint=("arg %d" % arg_num))
        except ValueError as e:
            raise click.BadParameter(
                    "%s: %r" % (str(e), arg),
                    param_hint=("arg %d" % arg_num))

    elif arg.startswith("./"):
        # The argument after `./` should be a single field,
        # whether a field name or a field key.
        field = arg[2:]
        if contains_commas or contains_spaces:
            # This is an invalid argument after `./`.
            raise click.BadParameter(
                    "argument after `./` should be just 1 field: %r" % arg,
                    param_hint=("arg %d" % arg_num))
        try:
            parsed_fields_to_show.remove_field(field)
        except KeyError as e:
            raise click.BadParameter(
                    "no such field name or field key %s: %r" % (str(e), arg),
                    param_hint=("arg %d" % arg_num))
        except ValueError as e:
            raise click.BadParameter(
                    "%s: %r" % (str(e), arg),
                    param_hint=("arg %d" % arg_num))

    else:  # arg.startswith(".")
        fields = arg[2:]
        if contains_commas or contains_spaces:
            # This is an invalid argument after `.`.
            # But let's avoid reporting a confusing/misleading error message.
            if "/" in fields:
                # It's probably intended to be a field-replacement.
                raise click.BadParameter(
                        "argument after `.` should be `newfield/oldfield`: %r" % arg,
                        param_hint=("arg %d" % arg_num))
            else:
                raise click.BadParameter(
                        "argument after `.` should be just 1 field: %r" % arg,
                        param_hint=("arg %d" % arg_num))

        field = arg[1:]
        if "/" in field:
            # It's a field-replacement.
            fields = field.split("/")
            if len(fields) != 2:
                # This is an invalid argument after `.`.
                raise click.BadParameter(
                        "argument after `.` should be `newfield/oldfield`: %r" % arg,
                        param_hint=("arg %d" % arg_num))
            # else, we have verified there are exactly 2 fields.
            (new_field, old_field) = fields
            try:
                parsed_fields_to_show.replace_field_in_place(old_field, new_field)
            except KeyError as e:
                raise click.BadParameter(
                        "no such field name or field key %s: %r" % (str(e), arg),
                        param_hint=("arg %d" % arg_num))
            except ValueError as e:
                raise click.BadParameter(
                        "%s: %r" % (str(e), arg),
                        param_hint=("arg %d" % arg_num))
        else:
            try:
                parsed_fields_to_show.show_field_first(field)
            except KeyError as e:
                raise click.BadParameter(
                        "no such field name or field key %s: %r" % (str(e), arg),
                        param_hint=("arg %d" % arg_num))
            except ValueError as e:
                raise click.BadParameter(
                        "%s: %r" % (str(e), arg),
                        param_hint=("arg %d" % arg_num))


def _parse_arg_start_equals(arg_num, arg, parsed_fields_to_show,
        contains_commas, contains_spaces):
    """Parse a command-line arg that starts with 1 or more dot (`=`) signs.

    An arg that starts with 2 equals characters, is used to override the list
    of fields to show.  There are no valid args that start with only 1 equals
    character.
    """
    if arg.startswith("=="):
        # The argument after `==` should be multiple fields, whether a list of
        # multiple comma/space-separated field names, or multiple field keys in
        # a single string.
        fields = arg[2:]
        if contains_commas or contains_spaces:
            # There are commas or spaces => Assume it's a list of field names.
            # Replace commas with spaces, so we only need to do one split.
            # Note that `.split()` also strips any leading & trailing whitespace.
            fields = (fields.replace(",", " ") if contains_commas else fields).split()
        try:
            parsed_fields_to_show.override_fields(fields)
        except KeyError as e:
            raise click.BadParameter(
                    "no such field name or field key %s: %r" % (str(e), arg),
                    param_hint=("arg %d" % arg_num))
        except ValueError as e:
            raise click.BadParameter(
                    "%s: %r" % (str(e), arg),
                    param_hint=("arg %d" % arg_num))

    else:  # arg.startswith("=")
        # As stated in the docstring for this function, there are no valid args
        # that start with only 1 equals character.
        raise click.BadParameter(
                "invalid argument: %r" % arg,
                param_hint=("arg %d" % arg_num))


def _parse_arg_start_percent(arg_num, arg, parsed_selection_criteria):
    """Parse a command-line arg that starts with 1 or more percent (`%`) signs.

    Args that start with 1 or more percent characters, all relate to selecting
    processes that have an associated TTY and/or a given executable name.
    """
    if arg.startswith("%%"):
        if arg == "%%":
            # Select ALL processes, even processes NOT associated with a TTY.
            # After this option or arg, all other args are redundant.
            parsed_selection_criteria.really_all_procs = True
        else:
            exe_start = arg[2:]
            parsed_selection_criteria.selection_criteria.add(
                    psquery_api.ProcessExeNameStartsWith(exe_start))

    else:  # arg.startswith("%")
        if arg == "%":
            parsed_selection_criteria.selection_criteria.add(
                    psquery_api.ProcessHasTty())
        else:
            exe_start = arg[1:]
            parsed_selection_criteria.selection_criteria.add(
                    psquery_api.ProcessHasTtyAndExeNameStartsWith(exe_start))


def _parse_arg_start_plus(arg_num, arg, parsed_selection_criteria, default_uid_criterion):
    """Parse a command-line arg that starts with 1 or more plus (`+`) signs.

    Args that start with 1 or more plus characters, all relate to selecting
    processes that are owned by a given integer UID (or Effective UID -- TBI).
    """
    if arg.startswith("++"):
        # TODO: Not Yet Implemented: Match the Effective UID.
        raise NotImplementedError("++ for matching Effective UID")
    else:  # arg.startswith("+")
        if arg == "+":
            # Match the caller's UID.
            parsed_selection_criteria.selection_criteria.add(
                    default_uid_criterion)
        else:
            try:
                # `int()` function ignores a single leading plus sign (`+`).
                uid = int(arg)
                parsed_selection_criteria.selection_criteria.add(
                        psquery_api.ProcessUidEquals(uid))
            except ValueError as e:
                raise click.BadParameter(
                        "invalid integer UID: %r" % arg,
                        param_hint=("arg %d" % arg_num))


def _try_parse_pid_list(arg_num, arg, parsed_selection_criteria,
        contains_commas, contains_spaces):
    """Parse a sequence of 1 or more integer PIDs, separated by spaces or commas.

    We only match numeric digits (without allowing preceding `+` or `-` signs),
    because we use integers preceded by a `+` sign to indicate UIDs (so they
    can't be confused with usernames that just happen to be all-digits); and
    because we use leading `-` signs only for options.

    This is why we don't just use the Python `int()` function for this check:
    because Python `int()` allows preceding `+` & `-` signs.

    We ignore leading whitespace, as long as there is eventually a PID integer.
    (We're trying to be flexible here, because we want to allow the caller some
    latitude in how this sequence of PIDs was generated.)

    We should already have checked that this arg does not contain:
      - multiple adjacent commas
      - a mixture of commas and spaces.
    """
    if not (contains_commas or contains_spaces):
        # No commas and no spaces => No splitting is necessary.
        # This argument is either a single valid PID integer, or not valid.
        # Match numeric digits only.
        if not arg.isdigit():
            raise click.BadParameter(
                    "invalid PID: %r" % arg,
                    param_hint=("arg %d" % arg_num))
        parsed_selection_criteria.selection_criteria.add(
                psquery_api.ProcessPidEquals(int(arg)))
    else:
        # This argument contains either commas or spaces (but recall
        # that we've already confirmed that it does NOT contain both).
        # Replace commas with spaces, so we only need to do one split.
        # Note that `.split()` also strips any leading & trailing whitespace.
        tokens = (arg.replace(",", " ") if contains_commas else arg).split()
        for tok in tokens:
            # Match numeric digits only.
            if not tok.isdigit():
                # Despite our flexibility, this is an invalid argument.
                raise click.BadParameter(
                        "invalid list of PIDs: %r" % arg,
                        param_hint=("arg %d" % arg_num))
            parsed_selection_criteria.selection_criteria.add(
                    psquery_api.ProcessPidEquals(int(tok)))


def _get_terminal_width():
    """Return the terminal width (number of columns of characters) or `None`.

    If this script's output is connected to a terminal, return the positive
    integer width in characters of the terminal; otherwise, if this script's
    output is connected to a pipeline, return `None`.

    This function uses Python stdlib function `shutil.get_terminal_size()`,
    which first attempts to use the `${COLUMNS}` environment variable.
    """
    (term_width, term_height) = shutil.get_terminal_size(fallback=(0, 0))
    return term_width if term_width > 0 else None

    # Originally I was using Click's function `click.get_terminal_size()` [1].
    # It works correctly when this script's output is connected to a terminal.
    # Unfortunately, if I pipe the output into some other program like `less`
    # or even just `cat`, Click's function always returns that the terminal is
    # 80 characters wide, even when the terminal is wider than 80 characters.
    # Click also does not offer any other way to determine whether the output
    # is connected to some other program.
    #
    # [1] https://click.palletsprojects.com/en/7.x/api/#click.get_terminal_size
    #
    # The Click source file "termui.py" [2] contains the definition of function
    # `click.get_terminal_size()` [3]:
    #
    # [2] /usr/local/lib/python3.6/site-packages/click/termui.py
    # [3] https://github.com/pallets/click/blob/master/src/click/termui.py#L219
    #
    # Reviewing the code of function `click.get_terminal_size()` [3] reveals
    # that it calls Python stdlib function `shutil.get_terminal_size()` [4][5],
    # which in turn calls Python stdlib function `os.get_terminal_size()` [6]
    # (after first attempting to read the `${COLUMNS}` environment variable).
    #
    # [4] https://docs.python.org/3/library/shutil.html#shutil.get_terminal_size
    # [5] https://github.com/python/cpython/blob/master/Lib/shutil.py#L1313
    # [6] https://docs.python.org/3/library/os.html#os.get_terminal_size
    #
    # If function `os.get_terminal_size()` [6] is not connected to a terminal,
    # it raises exception `OSError`:
    #     Traceback (most recent call last):
    #       <snip>
    #         print(os.get_terminal_size())
    #     OSError: [Errno 25] Inappropriate ioctl for device
    #
    # The incorrect (width, height) values come from the default parameter
    # `fallback=(80, 24)` of function `shutil.get_terminal_size()` [4][5],
    # which is returned if both of:
    #  - the `${COLUMNS}` environment variable is not set, or returns 0;
    # and:
    #  - function `os.get_terminal_size()` raises an exception.


def _format_memory_info(memory_info):
    """Format `memory_info` into a 2-line memory-usage header.

    The format of this 2-line memory-usage header is almost identical to the
    corresponding 2-line memory-usage header of the Linux/UNIX `top` program.

    The only intentional difference is that this format replaces the word "Mem"
    on the right-side of the 2nd line of the `top` header, with a percentage
    (in parentheses) of the "avail" memory as a proportion of the "total".

    For comparison, here is an example 2-line header returned by this function:
        KiB Mem :  3840888 total,   996016 free,  1897564 used,   947308 buff/cache
        KiB Swap:  8388604 total,  5490304 free,  2898300 used,  1440104 avail (37.5%)

    And here is the corresponding 2-line header of `top` running on Linux:
        KiB Mem :  3840888 total,  1010144 free,  1887936 used,   942808 buff/cache
        KiB Swap:  8388604 total,  5490304 free,  2898300 used.  1454240 avail Mem
    """
    line_1 = " ".join((
            "KiB Mem :",
            "{mi.mem_total_KiB:8d} total,",
            "{mi.mem_free_KiB:8d} free,",
            "{mi.mem_used_KiB:8d} used,",
            "{mi.mem_buff_cache_KiB:8d} buff/cache\n"))
    line_2 = " ".join((
            "KiB Swap:",
            "{mi.swap_total_KiB:8d} total,",
            "{mi.swap_free_KiB:8d} free,",
            "{mi.swap_used_KiB:8d} used,",
            "{mi.mem_avail_KiB:8d} avail",
            "({mi.mem_avail_perc:4.1f}%)"))

    return (line_1 + line_2).format(mi=memory_info)


def _format_overcommit_settings(overcommit_settings):
    """Format the Linux OOM `overcommit_settings` into a 1-line header.

    Here is an example returned by this function:
        Overcommit: mode = 0 "heuristic overcommit (default)", ratio = 50.0%
    """
    return "Overcommit: mode = {ov.mode} \"{ov.descr}\", ratio = {ov.ratio:4.1f}%\n".format(
            ov=overcommit_settings)


if __name__ == "__main__":
    oomps()
